<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AUTHORS" xml:space="preserve">
    <value>Deixe seu endereço de e-mail no comentário</value>
  </data>
  <data name="board_fw_version" xml:space="preserve">
    <value>Versão do firmware da placa</value>
  </data>
  <data name="bootloader_mode" xml:space="preserve">
    <value>Modo Bootloader</value>
  </data>
  <data name="connected_bl_mode" xml:space="preserve">
    <value>Conectado ao FlashcatUSB no modo bootloader</value>
  </data>
  <data name="connected_fw_ver" xml:space="preserve">
    <value>Conectado a {0}, versão do firmware: {1}</value>
  </data>
  <data name="console_complete" xml:space="preserve">
    <value>Aplicação concluída</value>
    <comment>Shown after the console mode has completed</comment>
  </data>
  <data name="mem_erasing_device" xml:space="preserve">
    <value>Apagar dispositivo de memória flash ... (isso pode levar até 2 minutos)</value>
  </data>
  <data name="console_exescript_req" xml:space="preserve">
    <value>Opção ExecuteScript requer opção -FILE para especificar qual script executar</value>
  </data>
  <data name="console_i2c_params" xml:space="preserve">
    <value>Parâmetros I2C: endereço escravo 0x{0}, deslocamento: 0x{1}, comprimento: {2} bytes</value>
  </data>
  <data name="console_i2c_reading" xml:space="preserve">
    <value>Lendo dados do dispositivo Flash I2C: {0} ({1} bytes)</value>
  </data>
  <data name="console_i2c_saved" xml:space="preserve">
    <value>Dados I2C salvos para: {0}</value>
  </data>
  <data name="console_i2c_write_error" xml:space="preserve">
    <value>Erro: incapaz de gravar no dispositivo I2C EEPROM</value>
  </data>
  <data name="console_i2c_write_success" xml:space="preserve">
    <value>A gravação I2C EEPROM foi bem sucedida</value>
  </data>
  <data name="console_i2c_writing" xml:space="preserve">
    <value>Escrevendo dados no dispositivo Flash I2C: {0} ({1} bytes)</value>
  </data>
  <data name="console_logappend" xml:space="preserve">
    <value>Anexe o texto do console a um arquivo existente</value>
  </data>
  <data name="console_mode_not_specified" xml:space="preserve">
    <value>MODE não especificado (isto é, -SPI ou -I2C)</value>
  </data>
  <data name="console_no_fcusb" xml:space="preserve">
    <value>Nenhum dispositivo FlashcatUSB conectado</value>
  </data>
  <data name="console_no_mem_devices" xml:space="preserve">
    <value>Não é possível executar quaisquer ações porque não há dispositivos de memória detectados</value>
  </data>
  <data name="console_operation_not_specified" xml:space="preserve">
    <value>OPERAÇÃO não especificada (i.e -READ ou -WRITE)</value>
  </data>
  <data name="console_opt_addr" xml:space="preserve">
    <value>Especifica o endereço do escravo I2C (ou seja, 0xA0)</value>
  </data>
  <data name="console_opt_eeprom" xml:space="preserve">
    <value>Especifica uma EEPROM SPI / I2C (ou seja, M95080 ou 24XX64)</value>
  </data>
  <data name="console_opt_erase" xml:space="preserve">
    <value>Execute um apagamento total da memória antes de escrever dados</value>
  </data>
  <data name="console_opt_exe" xml:space="preserve">
    <value>Permite que você execute um arquivo de script FlashcatUSB (* .fcs)</value>
  </data>
  <data name="console_opt_exit" xml:space="preserve">
    <value>Fechar automaticamente a janela quando concluída</value>
  </data>
  <data name="console_opt_file" xml:space="preserve">
    <value>Especifica o arquivo a ser usado para leitura / gravação / execução</value>
  </data>
  <data name="console_opt_help" xml:space="preserve">
    <value>Mostra esse diálogo</value>
    <comment>text seen in the console help menu</comment>
  </data>
  <data name="console_opt_length" xml:space="preserve">
    <value>Especifica o número de bytes para ler / escrever</value>
  </data>
  <data name="console_opt_list" xml:space="preserve">
    <value>Exibe os caminhos USB para todos os dispositivos FlashcatUSB conectados</value>
  </data>
  <data name="console_opt_log" xml:space="preserve">
    <value>Salve a saída do console em um arquivo</value>
  </data>
  <data name="console_opt_offset" xml:space="preserve">
    <value>Especifica o deslocamento para gravar o arquivo no flash</value>
  </data>
  <data name="console_opt_path" xml:space="preserve">
    <value>Selecione o FlashcatUSB para usar (use aspas em torno do caminho)</value>
  </data>
  <data name="console_opt_read" xml:space="preserve">
    <value>Executa uma operação de leitura de memória flash</value>
  </data>
  <data name="console_opt_verify" xml:space="preserve">
    <value>Desliga a verificação de dados para operações de gravação instantânea</value>
  </data>
  <data name="console_opt_write" xml:space="preserve">
    <value>Executa uma operação de gravação de memória flash</value>
  </data>
  <data name="console_progress" xml:space="preserve">
    <value>[{0}% concluído]</value>
    <comment>Progress bar for the console window</comment>
  </data>
  <data name="console_readmem_req" xml:space="preserve">
    <value>Operation ReadMemory requer opção -FILE para especificar onde salvar</value>
  </data>
  <data name="console_read_err_nodata" xml:space="preserve">
    <value>Erro: Leia não foi bem-sucedido porque não há dados para ler</value>
  </data>
  <data name="console_usb_list" xml:space="preserve">
    <value>Listando os caminhos de raiz USB para dispositivos FlashcatUSB conectados</value>
  </data>
  <data name="console_writemem_req" xml:space="preserve">
    <value>Operação WriteMemory requer opção -FILE para especificar onde salvar</value>
  </data>
  <data name="console_write_err_nodata" xml:space="preserve">
    <value>Erro: a gravação não foi bem-sucedida porque não há dados para escrever</value>
  </data>
  <data name="detecting_device" xml:space="preserve">
    <value>Detectando o dispositivo Flash conectado ...</value>
  </data>
  <data name="device_mode" xml:space="preserve">
    <value>Modo dispositivo</value>
  </data>
  <data name="device_mode_i2c" xml:space="preserve">
    <value>Modo de dispositivo configurado para I2C EEPROM, configure as configurações do I2C e clique em 'Detectar'</value>
  </data>
  <data name="disconnected_from_device" xml:space="preserve">
    <value>Desconectado do dispositivo {0}</value>
  </data>
  <data name="error_file_not_found" xml:space="preserve">
    <value>Erro, arquivo não encontrado: {0}</value>
  </data>
  <data name="err_file_not_found" xml:space="preserve">
    <value>Erro: arquivo não encontrado</value>
  </data>
  <data name="err_unable_to_connect" xml:space="preserve">
    <value>Erro: não é possível se conectar ao FlashcatUSB</value>
  </data>
  <data name="ext_4mbit_device" xml:space="preserve">
    <value>Dispositivo DIP32 / PLCC32 4MBIT detectado, permitindo a A18 no Pin 1 (reiniciar)</value>
  </data>
  <data name="io_mode_initalized" xml:space="preserve">
    <value>Modo paralelo inicializado com sucesso</value>
  </data>
  <data name="ext_board_not_detected" xml:space="preserve">
    <value>Não é possível conectar-se à placa de extensão E / S</value>
  </data>
  <data name="ext_connected_chipid" xml:space="preserve">
    <value>Conectado ao Flash (CHIP ID: 0x{0})</value>
  </data>
  <data name="ext_detecting_device" xml:space="preserve">
    <value>Tentando detectar automaticamente o dispositivo Flash</value>
  </data>
  <data name="ext_device_detected" xml:space="preserve">
    <value>Dispositivo detectado com sucesso no modo {0}</value>
  </data>
  <data name="ext_device_interface" xml:space="preserve">
    <value>Interface do dispositivo</value>
  </data>
  <data name="ext_init" xml:space="preserve">
    <value>Inicializando placa de hardware Paralelo Modo</value>
  </data>
  <data name="ext_large_flash_detected" xml:space="preserve">
    <value>Aviso: {0} dispositivo detectado, a porta de extensão só pode acessar até Mb512</value>
  </data>
  <data name="ext_not_detected" xml:space="preserve">
    <value>Dispositivo Flash não detectado no Paralelo Modo</value>
  </data>
  <data name="ext_page_size" xml:space="preserve">
    <value>Tamanho da página Flash: {0} bytes ({1} bytes estendidos)</value>
  </data>
  <data name="ext_prog_mode" xml:space="preserve">
    <value>Modo de programação: Paralelo Modo</value>
  </data>
  <data name="ext_write_mode_supported" xml:space="preserve">
    <value>Modo de gravação suportado</value>
  </data>
  <data name="flash_detected" xml:space="preserve">
    <value>Flash detectado: {0} ({1} bytes)</value>
  </data>
  <data name="fw_feat_supported" xml:space="preserve">
    <value>Recursos de firmware suportados</value>
  </data>
  <data name="fw_out_of_date" xml:space="preserve">
    <value>O firmware do FlashcatUSB está desactualizado, por favor, atualize</value>
  </data>
  <data name="fw_update_available" xml:space="preserve">
    <value>Atualização de firmware disponível, realizando atualização automática</value>
  </data>
  <data name="fw_update_error" xml:space="preserve">
    <value>Erro: não foi possível iniciar a atualização do firmware</value>
  </data>
  <data name="fw_update_performing" xml:space="preserve">
    <value>Atualização da unidade de firmware</value>
  </data>
  <data name="fw_update_programming" xml:space="preserve">
    <value>Programação de novo firmware no FlashcatUSB</value>
  </data>
  <data name="fw_update_starting" xml:space="preserve">
    <value>Início da atualização do firmware (envio de {0} bytes)</value>
  </data>
  <data name="i2c_addr_byte" xml:space="preserve">
    <value>I2C Byte de endereço: 0x{0}</value>
    <comment>I2C EEPROM ADDRESS</comment>
  </data>
  <data name="i2c_attempt_detect" xml:space="preserve">
    <value>Tentando detectar o dispositivo I2C EEPROM</value>
  </data>
  <data name="i2c_connected" xml:space="preserve">
    <value>Conectado com sucesso à EEPROM I2C</value>
  </data>
  <data name="i2c_detected" xml:space="preserve">
    <value>EECOM I2C detectada e pronta para operação</value>
  </data>
  <data name="i2c_eeprom_size" xml:space="preserve">
    <value>Tamanho do dispositivo I2C EEPROM: {0} bytes</value>
  </data>
  <data name="i2c_not_detected" xml:space="preserve">
    <value>EEPROM I2C não detectada</value>
  </data>
  <data name="i2c_protocol_speed" xml:space="preserve">
    <value>Velocidade do protocolo I2C</value>
  </data>
  <data name="i2c_unable_to_connect" xml:space="preserve">
    <value>Não é possível conectar-se a I2C EEPROM</value>
  </data>
  <data name="jtag_cfi_attempt_detect" xml:space="preserve">
    <value>Tentando detectar CFI flash no endereço 0x{0}</value>
  </data>
  <data name="jtag_cfi_no_detect" xml:space="preserve">
    <value>Erro: não é possível detectar o dispositivo flash CFI sobre JTAG</value>
  </data>
  <data name="jtag_dma" xml:space="preserve">
    <value>O dispositivo de destino suporta o modo DMA</value>
  </data>
  <data name="jtag_dma_not_supported" xml:space="preserve">
    <value>Erro: MCU não suporta acesso de registro DMA</value>
  </data>
  <data name="jtag_failed_to_connect" xml:space="preserve">
    <value>Falha ao conectar-se à placa-alvo usando JTAG</value>
  </data>
  <data name="jtag_no_dma" xml:space="preserve">
    <value>O dispositivo de destino não suporta o modo DMA</value>
  </data>
  <data name="jtag_no_idcode" xml:space="preserve">
    <value>O dispositivo não retornou IDCODE</value>
  </data>
  <data name="jtag_ready" xml:space="preserve">
    <value>{0} pronto para operação no modo JTAG</value>
  </data>
  <data name="jtag_setup" xml:space="preserve">
    <value>Configuração do mecanismo JTAG com sucesso</value>
  </data>
  <data name="jtag_spi_api_not_loaded" xml:space="preserve">
    <value>O software não suporta MCU para operação SPI</value>
  </data>
  <data name="jtag_spi_attempt_detect" xml:space="preserve">
    <value>Tentando detectar SPI flash conectado a MCU via JTAG</value>
  </data>
  <data name="jtag_spi_no_detect" xml:space="preserve">
    <value>Erro: não é possível detectar o dispositivo flash SPI sobre JTAG</value>
  </data>
  <data name="jtag_unknown_device" xml:space="preserve">
    <value>Dispositivo JTAG desconhecido</value>
  </data>
  <data name="mem_ask_continue" xml:space="preserve">
    <value>Continuar a operação de gravação?</value>
  </data>
  <data name="mem_bad_nand_block" xml:space="preserve">
    <value>BAD NAND BLOCK AT endereço: 0x{0}</value>
  </data>
  <data name="mem_erase_device" xml:space="preserve">
    <value>Executando um apagamento completo de fichas</value>
  </data>
  <data name="mem_erase_device_fail" xml:space="preserve">
    <value>Erro: apagando o dispositivo falhou</value>
  </data>
  <data name="mem_erase_device_success" xml:space="preserve">
    <value>Dispositivo de memória apagado com sucesso</value>
  </data>
  <data name="mem_erasing_sector" xml:space="preserve">
    <value>Erupção do setor de memória</value>
  </data>
  <data name="mem_flash_supported" xml:space="preserve">
    <value>Dispositivo Flash detectado com sucesso e pronto para operação</value>
  </data>
  <data name="mem_i2c_error" xml:space="preserve">
    <value>Erro ao se comunicar com o dispositivo I2C</value>
  </data>
  <data name="mem_not_supported" xml:space="preserve">
    <value>Memória flash detectada, mas não encontrada na biblioteca Flash</value>
  </data>
  <data name="mem_reading_memory" xml:space="preserve">
    <value>Memória de leitura de {0} bytes</value>
  </data>
  <data name="mem_verify_data" xml:space="preserve">
    <value>Verificando dados escritos</value>
  </data>
  <data name="mem_verify_failed" xml:space="preserve">
    <value>A verificação de dados falhou!</value>
  </data>
  <data name="mem_verify_failed_at" xml:space="preserve">
    <value>A verificação de dados falhou em 0x{0}</value>
  </data>
  <data name="mem_verify_failed_title" xml:space="preserve">
    <value>Falha na verificação de erro</value>
  </data>
  <data name="mem_verify_mismatches" xml:space="preserve">
    <value>Endereço {0}: escreveu {1} e lê {2} ({3} desajustes)</value>
  </data>
  <data name="mem_verify_okay" xml:space="preserve">
    <value>A verificação dos dados foi bem sucedida</value>
  </data>
  <data name="mem_write_not_successful" xml:space="preserve">
    <value>Erro, a operação de escrita não foi bem sucedida</value>
  </data>
  <data name="mem_write_successful" xml:space="preserve">
    <value>A operação de gravação foi bem sucedida</value>
  </data>
  <data name="mem_writing_memory" xml:space="preserve">
    <value>Escrevendo memória com {0} bytes</value>
  </data>
  <data name="nand_block_manager_disabled" xml:space="preserve">
    <value>Gerenciador de bloco NAND desativado</value>
  </data>
  <data name="nand_erase_failed" xml:space="preserve">
    <value>Erro ao apagar o dispositivo flash NAND</value>
  </data>
  <data name="nand_erase_successful" xml:space="preserve">
    <value>Removido com sucesso dispositivo NAND Flash</value>
  </data>
  <data name="nand_mem_device_detected" xml:space="preserve">
    <value>Dispositivo de memória NAND detectado, carregando mapa de memória válido</value>
  </data>
  <data name="nand_mem_map_complete" xml:space="preserve">
    <value>Mapa de memória NAND completo: {0} páginas disponíveis para acesso</value>
  </data>
  <data name="nand_mem_map_loading" xml:space="preserve">
    <value>Carregando o mapa de memória NAND para memória válida</value>
  </data>
  <data name="no_flash_detected" xml:space="preserve">
    <value>Nenhum flash detectado</value>
  </data>
  <data name="spinand_connected" xml:space="preserve">
    <value>Conectado ao SPI NAND Flash (RDID: {0})</value>
  </data>
  <data name="spinand_opened_device" xml:space="preserve">
    <value>Dispositivo aberto com sucesso no modo SPI NAND</value>
  </data>
  <data name="spi_attempting_detect" xml:space="preserve">
    <value>Tentando detectar o dispositivo SPI (modo de detecção automática)</value>
  </data>
  <data name="spi_connected_to_flash_spi" xml:space="preserve">
    <value>Conectado ao SPI Flash (RDID: {0} REMS: {1})</value>
  </data>
  <data name="spi_connected_to_flash_sqi" xml:space="preserve">
    <value>Conectado ao SQI Flash (RDID: {0})</value>
  </data>
  <data name="spi_detected_ls_spi" xml:space="preserve">
    <value>Detetou SPI Flash na porta SPI de baixa velocidade</value>
  </data>
  <data name="spi_detected_spi" xml:space="preserve">
    <value>Detectou SPI Flash na porta SPI de alta velocidade</value>
  </data>
  <data name="spi_detected_sqi" xml:space="preserve">
    <value>Detectou SPI Flash na porta SQI</value>
  </data>
  <data name="spi_device_not_found_sqi" xml:space="preserve">
    <value>Dispositivo aberto no modo SQI, mas não suportado na biblioteca Flash</value>
  </data>
  <data name="spi_device_opened" xml:space="preserve">
    <value>Dispositivo aberto com sucesso no modo SPI</value>
  </data>
  <data name="spi_eeprom_cfg" xml:space="preserve">
    <value>Configurado para usar o dispositivo SPI EEPROM</value>
  </data>
  <data name="spi_erase_complete" xml:space="preserve">
    <value>Apagar o flash completo em {0} segundos</value>
  </data>
  <data name="spi_erasing_die" xml:space="preserve">
    <value>Apagar o índice do flash: {0} ({1} bytes)</value>
  </data>
  <data name="spi_erasing_flash_device" xml:space="preserve">
    <value>Apagar dispositivo flash inteiro, tamanho total: {0} bytes (isso pode demorar um momento)</value>
  </data>
  <data name="spi_error_reading" xml:space="preserve">
    <value>SPI: Erro ao ler dados da porta USB</value>
  </data>
  <data name="spi_error_writing" xml:space="preserve">
    <value>SPI: Erro ao escrever dados na porta USB</value>
  </data>
  <data name="spi_flash_not_detected" xml:space="preserve">
    <value>Não é possível detectar o dispositivo SPI compatível</value>
  </data>
  <data name="spi_flash_page_size" xml:space="preserve">
    <value>Tamanho da eliminação da página: {0} bytes</value>
  </data>
  <data name="spi_mode_sqi" xml:space="preserve">
    <value>Modo de programação: SQI (SPI-QUAD)</value>
  </data>
  <data name="spi_nand_attempt_detect" xml:space="preserve">
    <value>Tentando detectar o dispositivo SPI NAND</value>
  </data>
  <data name="spi_nand_detected" xml:space="preserve">
    <value>Detectado com sucesso o dispositivo SPI NAND Flash</value>
  </data>
  <data name="spi_nand_unable_to_detect" xml:space="preserve">
    <value>Não foi possível detectar o dispositivo SPI NAND Flash</value>
  </data>
  <data name="spi_not_detected" xml:space="preserve">
    <value>Memória flash não detectada no modo SPI NOR</value>
  </data>
  <data name="spi_set_clock" xml:space="preserve">
    <value>Configurando o relógio SPI para: {0}</value>
  </data>
  <data name="spi_successfully_opened_sqi" xml:space="preserve">
    <value>Dispositivo aberto com sucesso no modo SQI</value>
  </data>
  <data name="spi_unable_detect" xml:space="preserve">
    <value>Não é possível detectar o dispositivo SPI NOR Flash</value>
  </data>
  <data name="successfully_connected" xml:space="preserve">
    <value>Conectado com sucesso ao FlashcatUSB por USB</value>
  </data>
  <data name="sw_requires_fw" xml:space="preserve">
    <value>O software requer a versão do firmware {0} ou mais recente</value>
  </data>
  <data name="unknown_device_email" xml:space="preserve">
    <value>Para suporte de dispositivo, envie um email para support@embeddedcomputers.net com o ID CHIP</value>
  </data>
  <data name="usb_driver_out_of_date" xml:space="preserve">
    <value>Seu driver FlashcatUSB está desatualizado, atualize seu driver para a versão mais recente incluída nesta versão do software</value>
  </data>
  <data name="usb_firm_out_of_date" xml:space="preserve">
    <value>Seu firmware FlashcatUSB está desatualizado, atualize a versão incluída nesta versão do software</value>
  </data>
  <data name="voltage_set_to" xml:space="preserve">
    <value>Tensão ajustada para: {0}</value>
  </data>
  <data name="welcome_to_flashcatusb" xml:space="preserve">
    <value>Bem-vindo ao software de interface FlashcatUSB</value>
  </data>
  <data name="gui_active_script" xml:space="preserve">
    <value>Script ativo</value>
    <comment>Label for the form</comment>
  </data>
  <data name="gui_compressed_img" xml:space="preserve">
    <value>Arquivo de arquivos compactados</value>
  </data>
  <data name="gui_console_text_copied" xml:space="preserve">
    <value>Texto do console copiado para a área de transferência</value>
  </data>
  <data name="gui_creating_nand_file" xml:space="preserve">
    <value>Criando arquivo de imagem flash NAND</value>
  </data>
  <data name="gui_database_supported" xml:space="preserve">
    <value>{0} banco de dados carregado: {1} dispositivos suportados</value>
    <comment>Displays how many flash devices the database contains</comment>
  </data>
  <data name="gui_fcusb_connected" xml:space="preserve">
    <value>Estado FlashcatUSB: conectado</value>
  </data>
  <data name="gui_fcusb_connected_multi" xml:space="preserve">
    <value>Status FlashcatUSB: conectados ({0} dispositivos)</value>
  </data>
  <data name="gui_fcusb_disconnected" xml:space="preserve">
    <value>Estado FlashcatUSB: desconectado</value>
  </data>
  <data name="gui_fcusb_new_device" xml:space="preserve">
    <value>Novo dispositivo conectado: {0}</value>
  </data>
  <data name="gui_gand_erase_all_confirm" xml:space="preserve">
    <value>Isso irá apagar todos os dispositivos Flash conectados, você tem certeza?</value>
  </data>
  <data name="gui_gane_write" xml:space="preserve">
    <value>Escreva</value>
    <comment>Button to program data into multi devices</comment>
  </data>
  <data name="gui_gang_choose_binary" xml:space="preserve">
    <value>Escolha um arquivo binário para programação</value>
  </data>
  <data name="gui_gang_devices_programmed" xml:space="preserve">
    <value>Todos os dispositivos Flash programados</value>
  </data>
  <data name="gui_gang_device_busy" xml:space="preserve">
    <value>Um ou mais dispositivos estão ocupados</value>
  </data>
  <data name="gui_gang_erase" xml:space="preserve">
    <value>Apagar</value>
    <comment>Button to erase memory device</comment>
  </data>
  <data name="gui_gang_erase_complete" xml:space="preserve">
    <value>Todos os dispositivos Flash foram apagados</value>
  </data>
  <data name="gui_gang_erasing" xml:space="preserve">
    <value>Apagar todos os dispositivos Flash</value>
  </data>
  <data name="gui_gang_info" xml:space="preserve">
    <value>Esta é a ferramenta de interface do programador multi-dispositivo</value>
  </data>
  <data name="gui_img_saved_to_disk" xml:space="preserve">
    <value>Imagem instantânea gravada no disco: {0}</value>
  </data>
  <data name="gui_img_successful" xml:space="preserve">
    <value>Imagem Flash Flash programada com sucesso no dispositivo atual</value>
  </data>
  <data name="gui_memory_device" xml:space="preserve">
    <value>Dispositivo de memória</value>
    <comment>The beginning label of each Flash memory device</comment>
  </data>
  <data name="gui_mem_device_status" xml:space="preserve">
    <value>Dispositivo {0}: Não conectado</value>
  </data>
  <data name="gui_mem_size" xml:space="preserve">
    <value>Tamanho da memória flash</value>
  </data>
  <data name="gui_menu_language" xml:space="preserve">
    <value>Língua</value>
    <comment>Name of the Language menu</comment>
  </data>
  <data name="gui_menu_main" xml:space="preserve">
    <value>Principal</value>
    <comment>Name of the Main menu</comment>
  </data>
  <data name="gui_menu_main_detect" xml:space="preserve">
    <value>Detectar (reinicializar)</value>
    <comment>Detects any connected Flash device</comment>
  </data>
  <data name="gui_menu_main_exit" xml:space="preserve">
    <value>Saída</value>
    <comment>Closes the application</comment>
  </data>
  <data name="gui_menu_main_refresh" xml:space="preserve">
    <value>Atualizar dispositivo flash</value>
    <comment>Updates the hex editor</comment>
  </data>
  <data name="gui_menu_main_repeat" xml:space="preserve">
    <value>Operação de gravação repetida</value>
    <comment>Allows to repeat the last programming operation</comment>
  </data>
  <data name="gui_menu_mode" xml:space="preserve">
    <value>Modo</value>
    <comment>Name of the Mode menu</comment>
  </data>
  <data name="gui_menu_mode_bitswap" xml:space="preserve">
    <value>Troca de bits</value>
  </data>
  <data name="gui_menu_mode_endian" xml:space="preserve">
    <value>Modo Endian</value>
  </data>
  <data name="gui_menu_mode_settings" xml:space="preserve">
    <value>Configurações de protocolo</value>
    <comment>The settings form</comment>
  </data>
  <data name="gui_menu_mode_verify" xml:space="preserve">
    <value>Verifique a programação</value>
    <comment>Makes the software read and verify after programming data</comment>
  </data>
  <data name="gui_menu_mode_voltage" xml:space="preserve">
    <value>Tensão ({0})</value>
    <comment>Sets the voltage of FCUSB Pro</comment>
  </data>
  <data name="gui_menu_mode_vpp" xml:space="preserve">
    <value>Configuração VPP</value>
  </data>
  <data name="gui_menu_script" xml:space="preserve">
    <value>Roteiro</value>
    <comment>Name of the Script menu</comment>
  </data>
  <data name="gui_menu_script_load" xml:space="preserve">
    <value>Carregar script</value>
    <comment>Loads and runs a script file</comment>
  </data>
  <data name="gui_menu_script_select" xml:space="preserve">
    <value>Selecionar script</value>
    <comment>Chooses a script file</comment>
  </data>
  <data name="gui_menu_script_unload" xml:space="preserve">
    <value>Script de descarregamento</value>
    <comment>Removes the script file/tab</comment>
  </data>
  <data name="gui_menu_tools" xml:space="preserve">
    <value>Ferramentas</value>
    <comment>Name of the Tools menu</comment>
  </data>
  <data name="gui_menu_tools_create" xml:space="preserve">
    <value>Criar imagem</value>
    <comment>Reads and creates an image file</comment>
  </data>
  <data name="gui_menu_tools_erase" xml:space="preserve">
    <value>Apagar chip</value>
    <comment>Erase a Flash device</comment>
  </data>
  <data name="gui_menu_tools_mem_map" xml:space="preserve">
    <value>Mapa de memória NAND</value>
  </data>
  <data name="gui_menu_tools_spi_ecc" xml:space="preserve">
    <value>SPI NAND ECC interno</value>
  </data>
  <data name="gui_menu_tools_vendor" xml:space="preserve">
    <value>Características do Vendedor</value>
  </data>
  <data name="gui_menu_tools_write" xml:space="preserve">
    <value>Escreva imagem</value>
    <comment>Programs an image file</comment>
  </data>
  <data name="gui_nand_creating_backup" xml:space="preserve">
    <value>Erro ao criar backup: ler memória retornou resultados inconsistentes</value>
  </data>
  <data name="gui_not_valid_img" xml:space="preserve">
    <value>Erro: o arquivo não é uma imagem Flash válida</value>
  </data>
  <data name="gui_open_img" xml:space="preserve">
    <value>Abra o arquivo de imagem do Flash para o programa</value>
  </data>
  <data name="gui_programming_img" xml:space="preserve">
    <value>Programação da imagem do Flash: {0}</value>
  </data>
  <data name="gui_reading_flash" xml:space="preserve">
    <value>Leitura de Flash: {0} de {1} bytes ({2}% concluído)</value>
  </data>
  <data name="gui_reading_spare_area" xml:space="preserve">
    <value>Leitura da área de reposição NAND: {0} de {1} bytes ({2}% concluído)</value>
  </data>
  <data name="gui_repeat_beginning" xml:space="preserve">
    <value>Execução de operação de gravação repetida, dispositivo de redefinição</value>
  </data>
  <data name="gui_repeat_failed_detect" xml:space="preserve">
    <value>Erro, não é possível detectar o dispositivo Flash para executar a operação repetida</value>
  </data>
  <data name="gui_repeat_failed_reconnect" xml:space="preserve">
    <value>Erro, incapaz de se reconectar ao FlashcatUSB</value>
  </data>
  <data name="gui_saved_img_to_disk" xml:space="preserve">
    <value>Imagem de Flash guardada no disco: {0}</value>
  </data>
  <data name="gui_save_dialog" xml:space="preserve">
    <value>Escolha o local para salvar o log do console</value>
  </data>
  <data name="gui_script_can_not_load" xml:space="preserve">
    <value>Não é possível carregar o script, o arquivo não existe</value>
  </data>
  <data name="gui_script_checking" xml:space="preserve">
    <value>Verificando um script específico do dispositivo para carregar automaticamente</value>
  </data>
  <data name="gui_script_loaded" xml:space="preserve">
    <value>Script carregado {0} com sucesso</value>
  </data>
  <data name="gui_script_loading" xml:space="preserve">
    <value>Carregando o script específico do dispositivo: {0}</value>
  </data>
  <data name="gui_script_non_available" xml:space="preserve">
    <value>Nenhum arquivo de script disponível</value>
  </data>
  <data name="gui_script_open" xml:space="preserve">
    <value>Selecione o arquivo de script FlashcatUSB para abrir</value>
  </data>
  <data name="gui_script_reset" xml:space="preserve">
    <value>O mecanismo do script FlashcatUSB foi reiniciado</value>
  </data>
  <data name="gui_select_location" xml:space="preserve">
    <value>Selecione o local para salvar o arquivo de imagem do Flash</value>
  </data>
  <data name="gui_status_welcome" xml:space="preserve">
    <value>Bem-vindo ao FlashcatUSB  (software de programação SPI / I2C / JTAG)!</value>
  </data>
  <data name="gui_tab_console" xml:space="preserve">
    <value>Console</value>
    <comment>Name of the console tab</comment>
  </data>
  <data name="gui_tab_multi" xml:space="preserve">
    <value>Multidispositivo</value>
    <comment>Name of the gang programming tab</comment>
  </data>
  <data name="gui_tab_status" xml:space="preserve">
    <value>Status</value>
    <comment>Name of the status tab</comment>
  </data>
  <data name="gui_vpp_confirm" xml:space="preserve">
    <value>Tem certeza de que deseja ativar esse recurso?</value>
    <comment>To enable to the +12V feature</comment>
  </data>
  <data name="gui_vpp_setting" xml:space="preserve">
    <value>Confirmar + Configuração VPP de 12V</value>
  </data>
  <data name="gui_vpp_warning" xml:space="preserve">
    <value>Aviso, esta configuração só deve ser usada com adaptadores com uma chave + 12V</value>
  </data>
  <data name="gui_writing_flash" xml:space="preserve">
    <value>Escrevendo Flash: {0} de {1} bytes ({2}% concluído)</value>
  </data>
  <data name="mc_badnand_block" xml:space="preserve">
    <value>BAD NAND BLOCK AT endereço: 0x{0} (Mapped to 0x{1})</value>
  </data>
  <data name="mc_button_alldata" xml:space="preserve">
    <value>Todos os dados</value>
    <comment>The NAND memory area selection button (both main and spare areas)</comment>
  </data>
  <data name="mc_button_cancel" xml:space="preserve">
    <value>Cancelar</value>
  </data>
  <data name="mc_button_close" xml:space="preserve">
    <value>Fechar</value>
    <comment>The close button on the compare popup window</comment>
  </data>
  <data name="mc_button_compare" xml:space="preserve">
    <value>Compare os conteúdos da memória</value>
    <comment>The popup text when your move your cursor over the button</comment>
  </data>
  <data name="mc_button_erase" xml:space="preserve">
    <value>Apague toda a memória</value>
    <comment>The popup text when your move your cursor over the button</comment>
  </data>
  <data name="mc_button_main" xml:space="preserve">
    <value>a Principal</value>
    <comment>The NAND memory area selection button (main part)</comment>
  </data>
  <data name="mc_button_ok" xml:space="preserve">
    <value>Está bem</value>
  </data>
  <data name="mc_button_read" xml:space="preserve">
    <value>Leia a memória no disco</value>
    <comment>The popup text when your move your cursor over the button</comment>
  </data>
  <data name="mc_button_spare" xml:space="preserve">
    <value>Poupar</value>
    <comment>The NAND memory area selection button (the spare or OOB)</comment>
  </data>
  <data name="mc_button_write" xml:space="preserve">
    <value>Escreva dados na memória</value>
    <comment>The popup text when your move your cursor over the button</comment>
  </data>
  <data name="mc_compare_canceled" xml:space="preserve">
    <value>Comparação de memória cancelada</value>
  </data>
  <data name="mc_compare_complete_match" xml:space="preserve">
    <value>A comparação de memória é completa: {0}% de correspondência de dados</value>
  </data>
  <data name="mc_compare_complete_tot" xml:space="preserve">
    <value>A comparação de memória é completa: {0} desajustes totais ({1}% correspondem)</value>
  </data>
  <data name="mc_compare_filename" xml:space="preserve">
    <value>Nome do arquivo</value>
  </data>
  <data name="mc_compare_flash_addr" xml:space="preserve">
    <value>Endereço de flash</value>
  </data>
  <data name="mc_compare_info" xml:space="preserve">
    <value>Endereço do Flash: 0x{0}, tamanho: {1} bytes</value>
  </data>
  <data name="mc_compare_mismatch" xml:space="preserve">
    <value>Contagem incompatível: {0} bytes ({1}% correspondência)</value>
  </data>
  <data name="mc_compare_results" xml:space="preserve">
    <value>Resultados de comparação de memória</value>
  </data>
  <data name="mc_compare_selected" xml:space="preserve">
    <value>Arquivo selecionado, comparando {0}</value>
  </data>
  <data name="mc_compare_start" xml:space="preserve">
    <value>Operação de comparação de memória inicial</value>
  </data>
  <data name="mc_compare_total_processed" xml:space="preserve">
    <value>Total de bytes processados</value>
  </data>
  <data name="mc_erase_command_sent" xml:space="preserve">
    <value>Mandar o comando de apagar memória para o dispositivo: {0}</value>
  </data>
  <data name="mc_erase_confirm" xml:space="preserve">
    <value>Confirmar apagar memória de {0}</value>
  </data>
  <data name="mc_erase_warning" xml:space="preserve">
    <value>Esta ação eliminará permanentemente todos os dados</value>
  </data>
  <data name="mc_io_destination" xml:space="preserve">
    <value>Endereço do Flash de destino: 0x{0}, bytes para escrever: {1} bytes</value>
  </data>
  <data name="mc_io_file_cancel_to" xml:space="preserve">
    <value>Usuário cancelado. Nenhum dado escrito em {0}</value>
  </data>
  <data name="mc_io_file_choose" xml:space="preserve">
    <value>Escolha o arquivo para escrever em {0}</value>
  </data>
  <data name="mc_io_file_compare" xml:space="preserve">
    <value>Selecione o arquivo para comparar com a memória</value>
  </data>
  <data name="mc_io_file_writing" xml:space="preserve">
    <value>Arquivo escolhido, escrevendo para {0}</value>
  </data>
  <data name="mc_io_open_file" xml:space="preserve">
    <value>Arquivo aberto para escrita: {0}, (tamanho: {1} bytes)</value>
  </data>
  <data name="mc_io_save_canceled" xml:space="preserve">
    <value>Usuário cancelado. Nenhum dado foi salvo</value>
  </data>
  <data name="mc_io_save_type" xml:space="preserve">
    <value>Escolha a localização do disco rígido e o formato de dados de saída</value>
  </data>
  <data name="mc_mem_read_begin" xml:space="preserve">
    <value>Memória de início lida de {0}</value>
  </data>
  <data name="mc_mem_read_canceled" xml:space="preserve">
    <value>Operação de leitura cancelada</value>
  </data>
  <data name="mc_mem_read_done" xml:space="preserve">
    <value>Operação de leitura completa</value>
  </data>
  <data name="mc_mem_read_from" xml:space="preserve">
    <value>Selecione o intervalo para ler de {0}</value>
  </data>
  <data name="mc_mem_read_result" xml:space="preserve">
    <value>Leia {0} bytes em {1} segundos, {2}</value>
  </data>
  <data name="mc_mem_read_start" xml:space="preserve">
    <value>Execução de operação de leitura de memória</value>
  </data>
  <data name="mc_mem_start_addr" xml:space="preserve">
    <value>Endereço de início: {0} ({1}) Comprimento: {2}</value>
  </data>
  <data name="mc_mem_user_cancel" xml:space="preserve">
    <value>Operação de leitura cancelada pelo usuário</value>
  </data>
  <data name="mc_mem_write_success" xml:space="preserve">
    <value>{0} salvo com sucesso no disco</value>
  </data>
  <data name="mc_reading" xml:space="preserve">
    <value>Leitura: {0} de {1}</value>
  </data>
  <data name="mc_rngbox_base" xml:space="preserve">
    <value>Endereço base</value>
    <comment>The flash address (starting point) of the operation</comment>
  </data>
  <data name="mc_rngbox_len" xml:space="preserve">
    <value>comprimento</value>
    <comment>The number of bytes to read/write</comment>
  </data>
  <data name="mc_select_range" xml:space="preserve">
    <value>Selecione o intervalo para gravar dados em {0}</value>
  </data>
  <data name="mc_wr_oper_complete" xml:space="preserve">
    <value>A operação de gravação completa, {0} bytes escrito</value>
  </data>
  <data name="mc_wr_oper_failed" xml:space="preserve">
    <value>A operação de gravação não foi bem sucedida</value>
  </data>
  <data name="mc_wr_oper_file_err" xml:space="preserve">
    <value>Erro, o arquivo não existe ou não contém dados</value>
  </data>
  <data name="mc_wr_oper_result" xml:space="preserve">
    <value>{0} bytes escritos em {1} segundos, {2} Bytes / s</value>
  </data>
  <data name="mc_wr_oper_start" xml:space="preserve">
    <value>Execução de operação de gravação de memória</value>
  </data>
  <data name="mc_wr_oper_status" xml:space="preserve">
    <value>Escrevendo o arquivo {0} em {1} ({2} bytes para escrever)</value>
  </data>
  <data name="mc_wr_user_canceled" xml:space="preserve">
    <value>Operação de gravação cancelada pelo usuário</value>
  </data>
  <data name="mem_verify_data_at" xml:space="preserve">
    <value>Verificando dados escritos em {0}</value>
  </data>
  <data name="settings_auto" xml:space="preserve">
    <value>Use configurações automáticas</value>
    <comment>Use automatic SPI settings</comment>
  </data>
  <data name="settings_blk_disabled" xml:space="preserve">
    <value>Desativado</value>
  </data>
  <data name="settings_box_block" xml:space="preserve">
    <value>Gerenciador de bloco ruim</value>
    <comment>The box for the block manager settings</comment>
  </data>
  <data name="settings_box_general" xml:space="preserve">
    <value>Geral</value>
    <comment>The general / common group box</comment>
  </data>
  <data name="settings_box_layout" xml:space="preserve">
    <value>Layout da área principal / sobressalente</value>
    <comment>The box to specify how to define the main and spare NAND areas</comment>
  </data>
  <data name="settings_mismatch" xml:space="preserve">
    <value>Na falta de correspondência de escrita, escreva dados para o próximo bloco</value>
  </data>
  <data name="settings_preserve_mem" xml:space="preserve">
    <value>Preserve áreas de memória</value>
  </data>
  <data name="settings_read_cmd" xml:space="preserve">
    <value>Ler comando</value>
    <comment>SPI command to read data</comment>
  </data>
  <data name="settings_specify" xml:space="preserve">
    <value>Use estas configurações</value>
    <comment>Use specific SPI command op codes</comment>
  </data>
  <data name="cfi_flash_base" xml:space="preserve">
    <value>CFI Flash base endereço: 0x{0}</value>
  </data>
  <data name="cfi_flash_detected" xml:space="preserve">
    <value>CFI compatível Flash detectado em 0x{0}</value>
  </data>
  <data name="cfi_flash_failed" xml:space="preserve">
    <value>Falha ao detectar o Flash compatível com CFI</value>
  </data>
  <data name="cfi_flash_info" xml:space="preserve">
    <value>Descrição do Flash CFI: {0} ({1} bytes)</value>
  </data>
  <data name="nand_reading_block" xml:space="preserve">
    <value>Leitura do bloco NAND {0} de {1} ({2}% completo)</value>
  </data>
  <data name="settings_combined" xml:space="preserve">
    <value>Combinado</value>
    <comment>both the main and spare are combined to create a single area</comment>
  </data>
  <data name="settings_disable_ecc" xml:space="preserve">
    <value>Desativar o gerador SPI-NAND ECC</value>
  </data>
  <data name="settings_nand_readverify" xml:space="preserve">
    <value>Usar Read-Verify em 'Criar imagem'</value>
  </data>
  <data name="settings_segmented" xml:space="preserve">
    <value>Segmented</value>
    <comment>the sections are split up (main, then spare, the main, etc.)</comment>
  </data>
  <data name="settings_seperate" xml:space="preserve">
    <value>Separado</value>
    <comment>seperage sections of the NAND page(main/spare areas)</comment>
  </data>
  <data name="nand_writing_block" xml:space="preserve">
    <value>Escrevendo o bloco NAND {0} de {1} ({2}% completo)</value>
  </data>
  <data name="nand_completed_with_blocks_left" xml:space="preserve">
    <value>Escrever imagem concluída com {0} blocos NAND não utilizados</value>
  </data>
  <data name="nand_missing_block" xml:space="preserve">
    <value>NAND Block faltando no arquivo de imagem: {0}</value>
  </data>
  <data name="settings_blk_1stbyte" xml:space="preserve">
    <value>1º byte:</value>
  </data>
  <data name="settings_blk_1stpage" xml:space="preserve">
    <value>Primeira página</value>
  </data>
  <data name="settings_blk_2ndpage" xml:space="preserve">
    <value>Segunda página</value>
  </data>
  <data name="settings_blk_6thbyte" xml:space="preserve">
    <value>6º byte:</value>
  </data>
  <data name="settings_blk_enabled" xml:space="preserve">
    <value>Ativado (verifique se há marcadores de bloco incorretos)</value>
  </data>
  <data name="settings_blk_lastpage" xml:space="preserve">
    <value>Última página</value>
  </data>
  <data name="mem_erase_failed_at" xml:space="preserve">
    <value>Falha ao apagar o Flash no endereço: 0x{0} (índice do setor: {1})</value>
  </data>
  <data name="mem_erase_failed_title" xml:space="preserve">
    <value>O apagamento do flash falhou</value>
  </data>
  <data name="console_eeprom_not_specified" xml:space="preserve">
    <value>O dispositivo EEPROM que você especificou não foi encontrado</value>
  </data>
  <data name="console_erase_not_valid" xml:space="preserve">
    <value>A opção Apagar é apenas para o modo -RARREIRO</value>
  </data>
  <data name="console_opt_erasechip" xml:space="preserve">
    <value>Apaga todo o dispositivo de memória</value>
  </data>
  <data name="console_opt_not_valid" xml:space="preserve">
    <value>Opção não reconhecida: {0}</value>
  </data>
  <data name="console_value_missing" xml:space="preserve">
    <value>Você deve especificar um valor a seguir - {0}</value>
  </data>
  <data name="console_value_numeric_hex" xml:space="preserve">
    <value>- {0} o valor deve ser numérico ou hexadecimal</value>
  </data>
  <data name="nandmngr_analyze" xml:space="preserve">
    <value>Analisar</value>
    <comment>Text for the button to check the entire flash for bad blocks</comment>
  </data>
  <data name="nandmngr_analyzed_done" xml:space="preserve">
    <value>Blocos NAND analisados ​​({0} blocos defeituosos encontrados)</value>
  </data>
  <data name="nandmngr_bad_block" xml:space="preserve">
    <value>Marcador de bloco ruim</value>
    <comment>Icon used for invalid block</comment>
  </data>
  <data name="nandmngr_bad_marker" xml:space="preserve">
    <value>marcador ruim</value>
  </data>
  <data name="nandmngr_block_map" xml:space="preserve">
    <value>Mapa de bloco NAND ({0} blocos totais; {1} bytes cada)</value>
  </data>
  <data name="nandmngr_close" xml:space="preserve">
    <value>Fechar</value>
    <comment>Close the block manager form</comment>
  </data>
  <data name="nandmngr_confim" xml:space="preserve">
    <value>Confirmar operação</value>
  </data>
  <data name="nandmngr_no_error" xml:space="preserve">
    <value>Sem erro</value>
    <comment>Icon used for valid block</comment>
  </data>
  <data name="nandmngr_selected_page" xml:space="preserve">
    <value>Página selecionada: {0} [bloco: {1}]</value>
  </data>
  <data name="nandmngr_title" xml:space="preserve">
    <value>Gerenciamento de bloco NAND ({0})</value>
  </data>
  <data name="nandmngr_user_discarded" xml:space="preserve">
    <value>usuário descartado</value>
    <comment>The user selected this block to ignore</comment>
  </data>
  <data name="nandmngr_user_marked" xml:space="preserve">
    <value>Usuário marcado</value>
    <comment>Icon used for user marked block to not use</comment>
  </data>
  <data name="nandmngr_valid" xml:space="preserve">
    <value>válido</value>
    <comment>Indicates the block is valid</comment>
  </data>
  <data name="nandmngr_verifing_block" xml:space="preserve">
    <value>Bloque de verificação: {0}</value>
  </data>
  <data name="nandmngr_warning" xml:space="preserve">
    <value>Atenção, esta operação irá apagar e substituir todos os blocos, continuar?</value>
  </data>
  <data name="nandmngr_write_error" xml:space="preserve">
    <value>Escrever erro</value>
    <comment>Icon used for block that failed write/read</comment>
  </data>
  <data name="nandmngr_write_marker" xml:space="preserve">
    <value>Escreva marcadores BAD BLOCK para área de reposição</value>
    <comment>Text for checkbox to have the software write data flags</comment>
  </data>
  <data name="mc_mem_converting_format" xml:space="preserve">
    <value>Convertendo arquivo binário para o formato de arquivo {0}</value>
  </data>
  <data name="mc_mem_incorrect_format" xml:space="preserve">
    <value>O arquivo selecionado não está no formato de arquivo {0}</value>
  </data>
  <data name="mc_mem_open_file_write" xml:space="preserve">
    <value>Arquivo aberto para escrita: {0} ({1}), tamanho total do arquivo: {2} bytes</value>
  </data>
  <data name="nandecc_algorithm" xml:space="preserve">
    <value>Algoritmo</value>
  </data>
  <data name="nandecc_biterror" xml:space="preserve">
    <value>Erro de bit</value>
  </data>
  <data name="nandecc_changes" xml:space="preserve">
    <value>As alterações produzem efeito no evento de detecção de dispositivo</value>
  </data>
  <data name="nandecc_ecclocation" xml:space="preserve">
    <value>Localização ECC</value>
  </data>
  <data name="nandecc_enabled" xml:space="preserve">
    <value>Activado</value>
  </data>
  <data name="nandecc_read_operation" xml:space="preserve">
    <value>Operação de leitura (auto-correção)</value>
  </data>
  <data name="nandecc_write_operation" xml:space="preserve">
    <value>Operação de gravação (ECC de gravação)</value>
  </data>
  <data name="nandecc_groupbox" xml:space="preserve">
    <value>Recurso de software ECC</value>
  </data>
  <data name="nandecc_revbyteorder" xml:space="preserve">
    <value>Ordem de byte reverso</value>
  </data>
  <data name="nandecc_symwidth" xml:space="preserve">
    <value>Largura do símbolo</value>
  </data>
  <data name="mc_button_all" xml:space="preserve">
    <value>Tudo</value>
    <comment>Select All</comment>
  </data>
</root>